<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Object Pool | i5 Toolkit Documentation </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Object Pool | i5 Toolkit Documentation ">
    <meta name="generator" content="docfx 2.56.2.0">
    
    <link rel="shortcut icon" href="../resources/Logos/Logo_whiteBg.svg">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    <meta property="docfx:rel" content="../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../resources/Logos/Logo_whiteBg.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="object-pool">Object Pool</h1>

<p><img src="../resources/Logos/ObjectPool.svg" alt="Object Pool"></p>
<h2 id="purpose">Purpose</h2>
<p><strong>The problem</strong>:
Usually, objects like <a class="xref" href="https://docs.unity3d.com/ScriptReference/GameObject.html">GameObjects</a> and <a class="xref" href="https://docs.unity3d.com/ScriptReference/Mesh.html">Meshes</a> are instantiated when they are needed so that they can be used in the scene.
If the object is not required anymore, it is usually destroyed.
Such calls of Unity&#39;s <a class="xref" href="https://docs.unity3d.com/ScriptReference/Object.html#Instantiate">Object</a> and <a class="xref" href="https://docs.unity3d.com/ScriptReference/Object.html#Destroy">Object</a> have a performance overhead which manifests in frame drops.
Destroyed objects also need to be collected by the garbage collector which intercepts the program execution and also leads to poor performance.
This is especially true if many objects need to be created or destroyed at once.</p>
<p><strong>The solution: Object Pools</strong>
A common technique to avoid such frame drops is to pool the objects.
This means that a number of objects are created in advance, e.g. at application startup.
At this point in time, a short loading time can be accepted since the application is most likely also loading other resources at that point.
After that, the application should only pull objects from the pool to use them.
Once the object is not required anymore, it is not destroyed but instead returned to the pool.
Hence, objects are recycled which can decrease the amount of times that the garbage collector runs.</p>
<h2 id="usage">Usage</h2>
<h3 id="requesting-objects">Requesting Objects</h3>
<p>You can use ObjectPools for any type of object.
To request an object, e.g. a GameObject from the pool, call the following:</p>
<pre><code class="lang-[C#]">GameObject fromPool = ObjectPool&lt;GameObject&gt;.RequestResource(() =&gt; {return new GameObject(&quot;Newly created&quot;);});
</code></pre><p><code>RequestResource</code> works in the following way:
It tries to fetch an object from the pool and returns it.
If the pool is empty, the method falls back to the factory method which is provided as an argument.
In the example, the factory method is given as a lambda function.
In general, the factory method should create a new instance of the object and return it.</p>
<h3 id="returning-objects">Returning Objects</h3>
<p>Once you do not need an object anymore, it must be returned to the pool so that other components can reuse it.
For instance, to return a GameObject <code>myGameObject</code>, call the following method:</p>
<pre><code class="lang-[C#]">ObjectPool&lt;GameObject&gt;.ReturnResource(myGameObject);
</code></pre><p><em>Important</em>:
Before you return the object, you should reset its properties.
The state in which you return the object is the state in which will receive the object again from the pool.
No internal modification are performed by the pool.</p>
<p>Moreover, it is advisable to bring objects into a storage state.
For GameObjects, it makes sense to deactivate them so that they are not visible in the scene while they are unused.
This also means that you have to activate the GameObject again once you retrieve it.</p>
<h3 id="clearing-pools">Clearing Pools</h3>
<p>The content of object pools can be cleared using the <code>ClearPool</code> method.</p>
<h3 id="working-with-separate-sub-pools-for-the-same-object-type">Working with Separate Sub-Pools for the Same Object Type</h3>
<p>In some cases, it makes sense to leave objects initialized in a specific state.
For instance, it makes no sense to remove components from GameObjects which are already set up if the same piece of application logic retrieves the GameObject later on and re-adds the same components.
Therefore, you can register sub-pools.
The purpose of these sub-pools is that you can return objects in a specific state to this pool and can expect it to have this state once you request the object from this sub-pool again.
As the sub-pool is separate, other components still work on the main pool and will not receive these objects which are in a different state.</p>
<p>Registering these separate pools works in the following way:</p>
<pre><code class="lang-[C#]">int poolId = ObjectPool&lt;GameObject&gt;.CreateNewPool();
</code></pre><p>This method will return an id by which the sub-pool can be addressed.
By default, the main pool of an object type always has the id 0.</p>
<p>Once you have obtained the id of the sub-pool, you can use the <code>RequestResource</code> and <code>ReturnResource</code> methods and specify the id as the first argument.</p>
<pre><code class="lang-[C#]">GameObject fromSubPool = ObjectPool&lt;GameObject&gt;.RequestResource(poolId, () =&gt; {return new GameObject();});
ObjectPool&lt;GameObject&gt;.ReturnResource(poolId, fromSubPool);
</code></pre><p>You can also remove sub-pools by calling the <code>RemovePool</code> method.</p>
<h2 id="test-scene">Test Scene</h2>
<p>There is a test scenes which demonstrates the usage with meshes.
The test scene was used to make sure that the pool fixes the memory leak problem that meshes introduce.
If meshes are not destroyed implicitly, they are never collected by the garbage collector, meaning that creating new meshes will fill the memory over time.
The <code>ObjectPool&lt;Mesh&gt;</code> pool solves this problem because the meshes can be recycled.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/rwth-acis/i5-Toolkit-for-Unity/blob/develop/Documentation/manual/Object-Pool.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            i5 Toolkit Documentation
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
